# Data-Analysis-and-Design

Project One: Analysis of Run-Time and Memory for Data Structures

In this project, I conducted an analysis of the run-time and memory usage for various data structures. This analysis helped me understand the efficiency and performance trade-offs when choosing the right data structure for a specific task.

Project Two: Course Sorting and Printing Program

This project involved developing a program that sorts and prints out a list of courses in the Computer Science program in alphanumeric order. The code demonstrates my ability to implement sorting algorithms and manage data in a way that is both efficient and user-friendly.

Reflection

Problem Solving Challenges
During this course, I encountered several challenges, particularly with setting up my development environment on a Mac. My Xcode setup was not up to date, leading to compatibility issues and significant delays. These problems highlighted the importance of maintaining an updated and well-configured environment to avoid unnecessary roadblocks.

Approach to Problem Solving
Data structures are a foundational aspect of computer science, and understanding their importance was key to my approach. By analyzing and selecting the appropriate data structures, I could design solutions that are not only efficient but also scalable and easy to maintain. Working ahead of deadlines allowed me to anticipate and resolve issues early, which was crucial given the technical difficulties I faced.

Overcoming Roadblocks
To overcome the challenges with Xcode and other technical issues, I took a proactive approach by starting my work ahead of time. This gave me the flexibility to troubleshoot and resolve problems without the pressure of looming deadlines. Additionally, I spent extra time revisiting concepts related to data structures to reinforce my understanding and ensure that I was applying the best practices in my code.

Expanding Software Design and Development Skills
These projects have significantly influenced my approach to designing software and developing programs. I've learned to prioritize the maintainability, readability, and adaptability of my code. Efficiency became a core focus, and I now consider the long-term implications of my design choices, particularly in terms of performance and memory usage.

Evolution in Writing Maintainable and Adaptable Programs
My work on these projects has evolved the way I write programs. I now place a greater emphasis on writing code that is not only functional but also clean and well-documented. By including extensive inline comments, I ensure that my code is understandable for others (and for myself in the future). This approach has made my programs more maintainable and easier to adapt for future needs.

